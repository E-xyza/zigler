const std = @import("std");
const Builder = std.build.Builder;
const Pkg = std.build.Pkg;

pub fn build(b: *Builder) void {
    const mode = b.standardReleaseOptions();
    const target = b.standardTargetOptions(.{});

    const erl_nif_pkg = Pkg{
        .name = "erl_nif",
        .source = .{ .path = "<%= Path.join(@beam_dir, "erl_nif.zig") %>"}
    };

    // compile-time options that modify default settings in beam.zig

    const opts_pkg = Pkg{
        .name = "zigler_options",
        .source = .{ .path = "options.zig" }
    };

    const beam_pkg = Pkg{
        .name = "beam",
        .source = .{ .path = "<%= Path.join(@beam_dir, "beam.zig") %>"},
        .dependencies = &.{erl_nif_pkg, opts_pkg},
    };

    const core_pkg = Pkg{
        .name = "nif",
        .source = .{ .path = "<%= @nif_path %>" },
        .dependencies = &.{beam_pkg, erl_nif_pkg},
    };

    const beam_system_dir = "<%= :code.root_dir() %>/erts-<%= :erlang.system_info(:version) %>/include";

    const lib = b.addSharedLibrary(
        "<%= @module %>",
        "nif.zig",
        .{ .versioned = .{.major = <%= @version.major %>,
                          .minor = <%= @version.minor %>,
                          .patch = <%= @version.patch %>}});
    lib.linkage = .dynamic;

    lib.addSystemIncludePath(beam_system_dir);
    lib.linkLibC();
    lib.addPackage(erl_nif_pkg);
    lib.addPackage(beam_pkg);
    lib.addPackage(core_pkg);
    <%= for lib <- @link_lib do %>
      <%= case lib do %>
        <% {:system, lib} -> %>
    lib.linkSystemLibrary("<%= lib %>");
        <% lib -> %>
    lib.addObjectFile("<%= lib %>");
      <% end %>
    <% end %>
    lib.setBuildMode(mode);
    lib.setTarget(target);

    lib.linker_allow_shlib_undefined = true;
    lib.install();

    const exe = b.addExecutable("sema", "sema.zig");
    exe.addSystemIncludePath(beam_system_dir);
    exe.linkLibC();
    exe.addPackage(erl_nif_pkg);
    exe.addPackage(beam_pkg);
    exe.addPackage(core_pkg);
    exe.install();

    const sema_step = b.step("sema", "Semantic Analysis");
    const sema_cmd = exe.run();
    sema_step.dependOn(&sema_cmd.step);
}
