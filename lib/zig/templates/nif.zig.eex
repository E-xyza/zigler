const beam = @import("beam");
const e = @import("erl_nif");
const nif = @import("nif");

<%= for nif <- @nifs do %>
<%= render_zig(nif) %>
<% end %>

// this function is used by resource.zig and must exist.  Will be templated later.
pub fn resource_lookup(comptime T: type) *e.ErlNifResourceType {
    _ = T;
    // CAUSE SEGFAULT IF THIS ACTUALLY GETS CALLED.
    return @intToPtr(*e.ErlNifResourceType, 0x1);
}

// this will be filled out later.
export fn load(env: ?*e.ErlNifEnv, priv_data: [*c]?*anyopaque, load_info: e.ErlNifTerm) c_int {
    _ = env;
    _ = priv_data;
    _ = load_info;
    return 0;
}

export var exported_nifs = [_]e.ErlNifFunc{<%= table_entries(@nifs) %>};

const entry = e.ErlNifEntry{
    .major = <%= nif_version(:major) %>,
    .minor = <%= nif_version(:minor) %>,
    .name = "<%= @module %>",
    .num_of_funcs = exported_nifs.len,
    .funcs = &exported_nifs,
    .load = load,
    .reload = null,   // never supported as of OTP 20
    .upgrade = beam.loader.blank_upgrade, 
    .unload = beam.loader.blank_unload,  
    .vm_variant = "beam.vanilla",
    .options = 1,
    .sizeof_ErlNifResourceTypeInit = @sizeOf(e.ErlNifResourceTypeInit),
    .min_erts = "erts-<%= :erlang.system_info(:version)%>"
};

<% # TODO: nif init that is separate, for windows %>

export fn nif_init() *const e.ErlNifEntry {
    return &entry;
}