const beam = @import("beam");
const std = @import("std");
const e = @import("erl_nif");
const nif = @import("nif");
const json = std.json;

// possibly 100 is an over-conservative choice for function depth here.
const JSON_DEPTH = 100;

// this needs to be here to mimic the resource_lookup function that's in the base nif file
pub fn assign_resource_type(comptime _: type, _: **e.ErlNifResourceType) void {
    @panic("sema should never call runtime assign_resource_type");
}

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    var stream = json.writeStream(stdout, JSON_DEPTH);
    <%= if opts[:nifs] == :all do %> <% # TODO: consider moving this conditional to build.zig %>
    try beam.sema.streamModule(&stream, nif);
    <% else %>
    try stream.beginObject();
    try stream.objectField("functions");
    try stream.beginArray();
    <%= for {nif, _nif_opt} <- opts[:nifs] do %>
    const <%= nif %> = @typeInfo(@TypeOf(nif.<%= nif %>)).Fn;
    try stream.arrayElem();
    try beam.sema.streamFun(&stream, "<%= nif %>", <%= nif %>);
    <% end %>
    try stream.endArray();
    try stream.endObject();
    <% end %>
}