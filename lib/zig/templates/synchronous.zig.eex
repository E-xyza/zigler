<% needs_make? = Enum.any?(@params, &Type.needs_make?/1) %>

export fn <%= @name %>(env: beam.env, _: c_int, arg: [*c] const e.ErlNifTerm) e.ErlNifTerm {
    <%= if needs_make? do %>
    var error_info = beam.make_empty_list(env); 
    <% end %>
    <%= for {param, index} <- Nif.indexed_parameters(@params) do %>
    const arg<%= index %> = 
      beam.get(
        <%= Type.to_call(param) %>, 
        env, 
        .{.v = arg[<%= index %>]}, 
        .{<%= if needs_make? do %>.error_info = &error_info<% end %>}) 
      catch |err| {
      <%= if needs_make? do %>
      return e.enif_raise_exception(env, beam.make(env, .{err, <%= index %>, error_info}, .{}).v);
      <% else %>
      return e.enif_raise_exception(env, beam.make(env, .{err, <%= index %>, beam.make_empty_list(env)}, .{}).v);
      <% end %>
    };
    <% end %>
    <%= case @params do %>
      <% [] -> %> _ = arg;
      <% [:env] -> %> _ = arg;
      <% _ ->  %>
    <% end %>
    <%= if @return == :void do %>
      nif.<%= @name %>(<%= Nif.indexed_args(@params) %>);
    <% else %>
      const result = nif.<%= @name %>(<%= Nif.indexed_args(@params) %>);
    <% end %>

    return <%= Type.make(@return, @opts).(:result) %>;
}